// ------------ Constructores seguros para el tipo ------------

// Mediante el uso de funciones bien nombradas como constructores en combinación con
// literales de funciones con receptor, es posible crear constructores seguros y de
// tipo estático en Kotlin.

// Los constructores de tipo seguro permiten crear lenguajes (DSL) específicos de
// dominio basados en Kotlin adecuados para construir estructuras de datos jerárquicas
// complejas de una manera semideclarativa. Ejemplos de casos de uso para los
// constructores son:

// Generar marcado con código Kotlin, como HTML o XML

// Configuración de rutas para un servidor web: Ktor

// Considere el siguiente código:

/*
import com.example.html.* // see declarations below

fun result() =
    html {
        head {
            title {+"XML encoding with Kotlin"}
        }
        body {
            h1 {+"XML encoding with Kotlin"}
            p  {+"this format can be used as an alternative markup to XML"}

            // an element with attributes and text content
            a(href = "https://kotlinlang.org") {+"Kotlin"}

            // mixed content
            p {
                +"This is some"
                b {+"mixed"}
                +"text. For more see the"
                a(href = "https://kotlinlang.org") {+"Kotlin"}
                +"project"
            }
            p {+"some text"}

            // content generated by
            p {
                for (arg in args)
                    +arg
            }
        }
    }
 */

// Este es un código Kotlin completamente legítimo. Puedes jugar con este código
// en línea (modificarlo y ejecutarlo en el navegador) aquí.

// ------------ Cómo funciona ------------

// Supongamos que necesita implementar un constructor de tipo seguro en Kotlin.
// En primer lugar, define el modelo que quieres construir. En este caso, necesitas
// modelar etiquetas HTML. Se hace fácilmente con un montón de clases. Por ejemplo,
// HTML es una clase que describe la etiqueta <html> que define a los niños como
// <head> y <body>. (Véase su declaración a continuación).

//Ahora, recordemos por qué puedes decir algo como esto en el código:

/*
html {
 // ...
}
 */

// Html es en realidad una llamada a una función que toma una expresión lambda como
// argumento. Esta función se define de la siguiente manera:

/*
fun html(init: HTML.() -> Unit): HTML {
    val html = HTML()
    html.init()
    return html
}
*/

// Esta función toma un parámetro llamado init, que es en sí mismo una función.
// El tipo de la función es HTML.() -> Unidad, que es un tipo de función con receptor.
// Esto significa que necesita pasar una instancia de tipo HTML (un receptor) a la
// función, y puede llamar a los miembros de esa instancia dentro de la función.

// Se puede acceder al receptor a través de esta palabra clave:

/*
html {
    this.head { ... }
    this.body { ... }
}
 */

// Ahora, esto se puede omitir, como de costumbre, y obtienes algo que ya se parece
// mucho a un constructor:

/*
html {
    head { ... }
    body { ... }
}
 */

// Entonces, ¿qué hace esta llamada? Echemos un vistazo al cuerpo de la función html
// como se definió anteriormente. Crea una nueva instancia de HTML, luego la inicializa
// llamando a la función que se pasa como argumento (en este ejemplo esto se reduce a
// llamar a la cabeza y el cuerpo en la instancia HTML), y luego devuelve esta instancia.
// Esto es exactamente lo que un constructor debería hacer.

// Las funciones de cabeza y cuerpo en la clase HTML se definen de manera similar a html.
// La única diferencia es que agregan las instancias construidas a la colección de hijos
// de la instancia HTML adjunta:

/*
fun head(init: Head.() -> Unit): Head {
    val head = Head()
    head.init()
    children.add(head)
    return head
}

fun body(init: Body.() -> Unit): Body {
    val body = Body()
    body.init()
    children.add(body)
    return body
}
 */

// En realidad, estas dos funciones hacen lo mismo, por lo que puedes tener una
// versión genérica, initTag:

/*
protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {
    tag.init()
    children.add(tag)
    return tag
}
 */

// Así que, ahora tus funciones son muy simples:

/*
fun head(init: Head.() -> Unit) = initTag(Head(), init)

fun body(init: Body.() -> Unit) = initTag(Body(), init)
 */

// Y puedes usarlos para crear etiquetas <head> y <body>.

// Otra cosa que se discutirá aquí es cómo se agrega texto a los cuerpos de
// las etiquetas. En el ejemplo anterior dices algo como:

/*
html {
    head {
        title {+"XML encoding with Kotlin"}
    }
    // ...
}
 */

// Así que, básicamente, solo tienes que poner una cadena dentro del cuerpo
// de una etiqueta, pero hay un pequeño + delante de él, por lo que es una
// llamada a la función que invoca una operación de prefijo unaryPlus().
// Esa operación en realidad está definida por una función de extensión
// unaryPlus() que es miembro de la clase abstracta TagWithText
// (un padre de Title):

/*
operator fun String.unaryPlus() {
    children.add(TextElement(this))
}
 */

// Entonces, lo que hace el prefijo + aquí es envolver una cadena en una
// instancia de TextElement y agregarla a la colección de hijos, para que
// se convierta en una parte adecuada del árbol de etiquetas.

// Todo esto se define en un paquete com.example.html que se importa en la
//  parte superior del ejemplo de construcción anterior. En la última sección
//  puedes leer la definición completa de este paquete.

// ------------ Control de alcance: @DslMarker ------------

// Al usar DSL, uno podría haber encontrado el problema de que se pueden llamar
// a demasiadas funciones en el contexto. Puede llamar a los métodos de cada
// receptor implícito disponible dentro de un lambda y, por lo tanto, obtener
// un resultado inconsistente, como la cabeza de etiqueta dentro de otra cabeza:

/*
html {
    head {
        head {} // should be forbidden
    }
    // ...
}
*/

// En este ejemplo, solo los miembros del receptor implícito más cercano this@head
// deben estar disponibles; head() es un miembro del receptor externo this@html,
// por lo que debe ser ilegal llamarlo.

// Para abordar este problema, existe un mecanismo especial para controlar el alcance
// del receptor.

// Para hacer que el compilador comience a controlar los ámbitos, solo tiene que anotar
// los tipos de todos los receptores utilizados en el DSL con la misma anotación de marcador.
// Por ejemplo, para los constructores de HTML, usted declara una anotación @HTMLTagMarker:

/*
@DslMarker
annotation class HtmlTagMarker
*/

// Una clase de anotación se llama marcador DSL si está anotada con la anotación @DslMarker.

// En nuestro DSL, todas las clases de etiquetas extienden la misma etiqueta de superclase.
// Basta con anotar solo la superclase con @HtmlTagMarker y después de eso el compilador
// de Kotlin tratará todas las clases heredadas como anotadas:

/*
@HtmlTagMarker
abstract class Tag(val name: String) { ... }
 */

// No tienes que anotar las clases HTML o Head con @HtmlTagMarker porque su superclase
// ya está anotada:

/*
class HTML() : Tag("html") { ... }

class Head() : Tag("head") { ... }
*/

// Después de agregar esta anotación, el compilador de Kotlin sabe qué receptores
// implícitos forman parte del mismo DSL y permite llamar solo a los miembros de
// los receptores más cercanos:

/*
html {
    head {
        head { } // error: a member of outer receiver
    }
    // ...
}
*/

// Tenga en cuenta que todavía es posible llamar a los miembros del receptor externo,
// pero para hacerlo tiene que especificar este receptor explícitamente:

/*
html {
    head {
        this@html.head { } // possible
    }
    // ...
}
*/

// ------------ Definición completa del paquete com.example.html ------------

// Así es como se define el paquete com.example.html (solo los elementos utilizados en el
// ejemplo anterior). Construye un árbol HTML. Hace un gran uso de las funciones de
// extensión y las lambdas con receptor.

package com.example.html

interface Element {
    fun render(builder: StringBuilder, indent: String)
}

class TextElement(val text: String) : Element {
    override fun render(builder: StringBuilder, indent: String) {
        builder.append("$indent$text\n")
    }
}

@DslMarker
annotation class HtmlTagMarker

@HtmlTagMarker
abstract class Tag(val name: String) : Element {
    val children = arrayListOf<Element>()
    val attributes = hashMapOf<String, String>()

    protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {
        tag.init()
        children.add(tag)
        return tag
    }

    override fun render(builder: StringBuilder, indent: String) {
        builder.append("$indent<$name${renderAttributes()}>\n")
        for (c in children) {
            c.render(builder, indent + "  ")
        }
        builder.append("$indent</$name>\n")
    }

    private fun renderAttributes(): String {
        val builder = StringBuilder()
        for ((attr, value) in attributes) {
            builder.append(" $attr=\"$value\"")
        }
        return builder.toString()
    }

    override fun toString(): String {
        val builder = StringBuilder()
        render(builder, "")
        return builder.toString()
    }
}

abstract class TagWithText(name: String) : Tag(name) {
    operator fun String.unaryPlus() {
        children.add(TextElement(this))
    }
}

class HTML : TagWithText("html") {
    fun head(init: Head.() -> Unit) = initTag(Head(), init)

    fun body(init: Body.() -> Unit) = initTag(Body(), init)
}

class Head : TagWithText("head") {
    fun title(init: Title.() -> Unit) = initTag(Title(), init)
}

class Title : TagWithText("title")

abstract class BodyTag(name: String) : TagWithText(name) {
    fun b(init: B.() -> Unit) = initTag(B(), init)
    fun p(init: P.() -> Unit) = initTag(P(), init)
    fun h1(init: H1.() -> Unit) = initTag(H1(), init)
    fun a(href: String, init: A.() -> Unit) {
        val a = initTag(A(), init)
        a.href = href
    }
}

class Body : BodyTag("body")
class B : BodyTag("b")
class P : BodyTag("p")
class H1 : BodyTag("h1")

class A : BodyTag("a") {
    var href: String
        get() = attributes["href"]!!
        set(value) {
            attributes["href"] = value
        }
}

fun html(init: HTML.() -> Unit): HTML {
    val html = HTML()
    html.init()
    return html
}
